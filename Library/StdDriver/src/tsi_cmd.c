/*************************************************************************//**
 * @file     tsi_cmd.c
 * @brief    MA35D1 TSI driver
 *
 * @copyright (C) 2023 Nuvoton Technology Corp. All rights reserved.
*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "MA35D1.h"
#include "whc.h"
#include "tsi_cmd.h"

/** @addtogroup Standard_Driver Standard Driver
  @{
*/

/** @addtogroup TSI_Driver TSI Driver
  @{
*/

/** @addtogroup TSI_EXPORTED_FUNCTIONS TSI Exported Functions
  @{
*/

/// @cond HIDDEN_SYMBOLS

//#define USE_IRQ

typedef struct err_code_t
{
	int    code;
	char   str[32];

}  ERR_CODE_T;

ERR_CODE_T  _err_code_tbl[] =
{
	ST_SUCCESS,               "ST_SUCCESS",
	ST_WAIT_TSI_SYNC,         "ST_WAIT_TSI_SYNC",
	ST_UNKNOWN_CMD,           "ST_UNKNOWN_CMD",
	ST_NO_TSI_IMAGE,          "ST_NO_TSI_IMAGE",
	ST_CMD_QUEUE_FULL,        "ST_CMD_QUEUE_FULL",
	ST_TIME_OUT,              "ST_TIME_OUT",
	ST_INVALID_PARAM,         "ST_INVALID_PARAM",
	ST_NO_AVAIL_SESSION,      "ST_NO_AVAIL_SESSION",
	ST_INVALID_SESSION_ID,    "ST_INVALID_SESSION_ID",
	ST_INVALID_OPERATION,     "ST_INVALID_OPERATION",
	ST_HW_NOT_READY,          "ST_HW_NOT_READY",
	ST_HW_ERROR,              "ST_HW_ERROR",
	ST_HW_BUSY,               "ST_HW_BUSY",
	ST_HW_TIME_OUT,           "ST_HW_TIME_OUT",
	ST_BUS_ERROR,             "ST_BUS_ERROR",
	ST_ECC_UNKNOWN_CURVE,     "ST_ECC_UNKNOWN_CURVE",
	ST_ECC_INVALID_PRIV_KEY,  "ST_ECC_INVALID_PRIV_KEY",
	ST_SIG_VERIFY_ERROR,      "ST_SIG_VERIFY_ERROR",
	ST_KS_READ_PROTECT,       "ST_KS_READ_PROTECT",
	ST_KS_FULL,               "ST_KS_FULL",
	ST_WHC_TX_BUSY,           "ST_WHC_TX_BUSY",
	ST_CMD_ACK_TIME_OUT,      "ST_CMD_ACK_TIME_OUT",
};

#ifdef USE_IRQ

static volatile int  whc1_irq;

static void set_whc1_irq_flag(int val)
{
	isb();
	whc1_irq = val;
	isb();
}

static int get_whc1_irq_flag(void)
{
	isb();
	return whc1_irq;
}

void WRHO1_IRQHandler(void)
{
	int  i;
	uint32_t  intsts;

	intsts = WHC1->INTSTS;

	if (intsts & (WHC_INTSTS_RX3IF_Msk | WHC_INTSTS_RX2IF_Msk |
		WHC_INTSTS_RX1IF_Msk | WHC_INTSTS_RX0IF_Msk))
	{
		set_whc1_irq_flag(1);
	}
	WHC1->INTSTS = 0x0f00003f;
}

#else

static void set_whc1_irq_flag(int val) {}

static int get_whc1_irq_flag(void)
{
	if (WHC1->RXSTS & 0xf)
		return 1;
	else
		return 0;
}

#endif

static uint32_t get_time(void)
{
	return EL0_GetCurrentPhysicalValue() / 12000;
}

int tsi_wait_ack(TSI_REQ_T *req, int time_out)
{
	int        i;
	uint64_t   t0;

	t0 = EL0_GetCurrentPhysicalValue();
	while (!get_whc1_irq_flag())
	{
		if (time_out && (EL0_GetCurrentPhysicalValue() - t0 > (time_out * 12000)))
		{
			/* command time-out, recall message */
			WHC1->TXCTL = (1<<(16+req->tx_channel));
			return ST_CMD_ACK_TIME_OUT;
		}
	}
	for (i = 0; i < 4; i++)
	{
		if (WHC1->RXSTS & (1 << i))         /* Check CHxRDY */
		{
			if ((WHC1->RMDAT[i][0] & TCK_CHR_MASK) == (req->cmd[0] & TCK_CHR_MASK))
			{
				req->ack[0] = WHC1->RMDAT[i][0];
				req->ack[1] = WHC1->RMDAT[i][1];
				req->ack[2] = WHC1->RMDAT[i][2];
				req->ack[3] = WHC1->RMDAT[i][3];
				WHC1->RXCTL = (1 << i);     /* set CHxACK */
				// sysprintf("[%d] ACK: 0x%x 0x%x 0x%x 0x%x\n", get_time(), req->ack[0], req->ack[1], req->ack[2], req->ack[3]);
				return 0;
			}
			else
			{
				req->ack[0] = WHC1->RMDAT[i][0];
				req->ack[1] = WHC1->RMDAT[i][1];
				req->ack[2] = WHC1->RMDAT[i][2];
				req->ack[3] = WHC1->RMDAT[i][3];
				// sysprintf("[%d] [%d] INVALID ACK: 0x%x 0x%x 0x%x 0x%x\n", get_time(), i, req->ack[0], req->ack[1], req->ack[2], req->ack[3]);
				WHC1->RXCTL = (1 << i);     /* set CHxACK */
				return 0;
			}
		}
	}
	sysprintf("tsi_wait_ack - error, irq occurred, but ack not received!!\n");
}

int tsi_send_command(TSI_REQ_T *req)
{
	int        i;

	for (i = 0; i < 4; i++)
	{
		if (WHC1->TXSTS & (1<<i))      /* Check CHxRDY */
			break;
	}
	if (i >= 4)
		return ST_WHC_TX_BUSY;         /* No WHC channel is ready for sending message */

	// sysprintf("[%d] CMD: 0x%x 0x%x 0x%x 0x%x\n", get_time(), req->cmd[0], req->cmd[1], req->cmd[2], req->cmd[3]);

	WHC1->TMDAT[i][0] = req->cmd[0];
	WHC1->TMDAT[i][1] = req->cmd[1];
	WHC1->TMDAT[i][2] = req->cmd[2];
	WHC1->TMDAT[i][3] = req->cmd[3];

	set_whc1_irq_flag(0);
	WHC1->TXCTL = (1 << i);            /* send message */
	req->tx_channel = i;
	req->tx_jiffy = EL0_GetCurrentPhysicalValue();
	return 0;
}

int tsi_send_command_and_wait(TSI_REQ_T *req, int time_out)
{
	int  ret;

	ret = tsi_send_command(req);
	if (ret != 0)
		return ret;

	ret = tsi_wait_ack(req, time_out);
	if (ret != 0)
		return ret;

	return TA_GET_STATUS(req);
}

/// @endcond HIDDEN_SYMBOLS

/**
  * @brief      Print human readable error messages to debug port.
  * @param[in]  code    TSI error code
  */
void TSI_Print_Error(int code)
{
	int   i;

	for (i = 0; i < sizeof(_err_code_tbl)/sizeof(ERR_CODE_T); i++)
	{
		if (_err_code_tbl[i].code == code)
		{
			sysprintf("  [%s]\n", _err_code_tbl[i].str);
			return;
		}
	}
	sysprintf("\nUnknow error code 0x%x!\n", code);
}

/**
  * @brief    Force TSI back to the initial state.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Sync(void)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = CMD_TSI_SYNC << 16;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Get the version of TSI firmware.
  * @param[out]  ver_code     TSI firmware version code.
  * @return   0               success
  * @return   otherwise    error code from TSI
  */
int TSI_Get_Version(uint32_t *ver_code)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = CMD_TSI_GET_VERSION << 16;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*ver_code = req.ack[1];
	return ret;
}

/**
  * @brief    Reset TSI immediately.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Reset(void)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = CMD_TSI_RESET << 16;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief    Configure TSI UART port
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Config_UART(uint32_t line, uint32_t baud)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = CMD_TSI_CONFIG_UART<<16;
	req.cmd[1] = 0x11520087;
	req.cmd[2] = line;
	req.cmd[3] = baud;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}


/**
  * @brief    Set TSI PLL clock. (MA35D1 SYS-PLL)
  * @param[in]  pllctl     The value to be written to TSI PLL_CTL register
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Set_Clock(uint32_t pllctl)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_SET_CLOCK << 16);
	req.cmd[1] = pllctl;

	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret != 0)
		return ret;
	return 0;
}

/**
  * @brief    Load a patch image to TSI
  * @param[in]  base       Load address of the TSI image.
  * @param[in]  size       Size of the TSI image.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Load_Image(uint32_t base, uint32_t size)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_LOAD_EX_FUNC << 16);
	req.cmd[1] = base;
	req.cmd[2] = size;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret != 0)
		return ret;
	return 0;
}

/**
  * @brief    Request to monitor a memory block.
  * @param[in]  base      Base address of the memory block to minitor.
  * @param[in]  size      Byte count of the memory block to minitor.
  * @param[in]  interval  Monitor time interval in seconds.
  * @param[out] id        Monitor ID
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Monitor_Set(uint32_t base, uint32_t size, int interval, int *id)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_MONITOR_SET << 16);
	req.cmd[1] = interval & 0xffff;
	req.cmd[2] = base;
	req.cmd[3] = size;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret != 0)
		return ret;
	*id = req.ack[1] & 0xff;
	return 0;
}

/**
  * @brief    Get TSI monitor area status
  * @param[in]  id         ID of the monitor.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Monitor_Status(int id)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_MONITOR_STATUS << 16) | (id & 0xff);
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Close a TSI monitor process.
  * @param[in]  id         ID of the monitor.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Monitor_Close(int id)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_MONITOR_CLOSE << 16) | (id & 0xff);
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Request an encrypt/decrypt session for AES or SHA.
  * @param[in]   class_code   The command class. Should be C_CODE_AES or C_CODE_SHA.
  * @param[out]  session_id   The session ID.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Open_Session(int class_code, int *session_id)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_OPEN_SESSION << 16) | class_code;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret != 0)
		return ret;
	*session_id = req.ack[1] & 0xff;
	return 0;
}

/**
  * @brief    Close an opened session.
  * @param[in]   class_code   The command class. Should be C_CODE_AES or C_CODE_SHA.
  * @param[in]   session_id   The session ID.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_Close_Session(int class_code, int session_id)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TSI_CLOSE_SESSION<<16) | (class_code<<8) | session_id;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}


/**
  * @brief    TRNG init
  * @param[in]   method    0x0: Self-seeding. Seed is from TRNG noise
  *                        0x1: Nonce seeding. Seed is from noise and user provied nonce data,
  *                             which is put in parameter block and length is 48 words.
  *                        0x2: User seed. Seed is from user provided data, which is put in
  *                             parameter block and length is 12 words.
  * @param[in]   pb_addr   Address of parameter block. Not used if "method" is 0.
  *                        If "method" is 0x1, "param" should contains 48 words nounce data.
  *                        If "method" is 0x2, "param" should contains 12 words user defined seed.
  * @return   0            success
  * @return   otherwise    error code from TSI
  */
int TSI_TRNG_Init(int method, uint32_t pb_addr)
{
	TSI_REQ_T  req;
	int  ret;

	if ((method != 0) && (method != 1) && (method != 2))
		return ST_INVALID_PARAM;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TRNG_INIT << 16) | method;
	req.cmd[1] = pb_addr;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief    Request TRNG to generate random numbers.
  * @param[in]  wcnt          Word count of random numbers
  * @param[in]  dest_addr     Destination address.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_TRNG_Gen_Random(uint32_t wcnt, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_TRNG_GEN_RANDOM << 16);
	req.cmd[2] = wcnt;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}


/**
  * @brief    PRNG re-seed
  * @param[in]   seed_src   Specify the source of PRNG seed
  *                         - 0:  Seed is generated from TSI TRNG.
  *                         - 1:  Use the "seed" as PRNG seed.
  * @param[in]   seed       PRNG seed
  * @return   0             success
  * @return   otherwise     error code from TSI
  */
int TSI_PRNG_ReSeed(int seed_src, uint32_t seed)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_PRNG_RESEED << 16);
	req.cmd[1] = seed_src;
	req.cmd[2] = seed;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief    Request PRNG to generate a 64-bits random number.
  * @param[out]  rnd_w0       random number word 0
  * @param[out]  rnd_w1       random number word 1
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_PRNG_Gen_Random(uint32_t *rnd_w0, uint32_t *rnd_w1)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_PRNG_GEN_RANDOM << 16);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*rnd_w0 = req.ack[1];
	*rnd_w1 = req.ack[2];
	return ret;
}

/**
  * @brief    Request PRNG to generate mass random numbers.
  * @param[in]  wcnt          Word count of random numbers
  * @param[in]  dest_addr     Destination address.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_PRNG_Gen_Random_Mass(uint32_t wcnt, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_PRNG_GEN_RAN_MASS << 16);
	req.cmd[2] = wcnt;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}


/**
  * @brief    Request PRNG to generate a random key to Key Store SRAM
  * @param[in]  owner       Owner of the random key.
  *                         0x0: Only for AES used
  *                         0x1: Only for HMAC used
  *                         0x4: Only for ECC used
  *                         0x5: Only for CPU used
  * @param[in]  is_ecdsa    1: Only for ECC ECDSA
  * @param[in]  is_ecdh     1: Only for ECC ECDH
  * @param[in]  keysz       Random key size
  *                             \ref KS_META_128
  *                             \ref KS_META_163
  *                             \ref KS_META_192
  *                             \ref KS_META_224
  *                             \ref KS_META_233
  *                             \ref KS_META_255
  *                             \ref KS_META_256
  *                             \ref KS_META_283
  *                             \ref KS_META_384
  *                             \ref KS_META_409
  *                             \ref KS_META_512
  *                             \ref KS_META_521
  *                             \ref KS_META_571
  *                             \ref KS_META_1024
  *                             \ref KS_META_2048
  *                             \ref KS_META_4096
  *                             \ref KS_META_READABLE
  *                             \ref KS_META_PRIV
  *                             \ref KS_META_NONPRIV
  *                             \ref KS_META_SECURE
  * @param[out]  key_num   Key Store KS_SRAM key number of the random key
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_PRNG_GenTo_KS_SRAM(uint32_t owner, int is_ecdsa, int is_ecdh, uint32_t keysz, int *key_num)
{
	TSI_REQ_T  req;
	int        ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_PRNG_GEN_KS_SRAM << 16);
	req.cmd[1] = (owner << CRYPTO_PRNG_KSCTL_OWNER_Pos) | (keysz >> KS_METADATA_SIZE_Pos);
	if (is_ecdh)
		req.cmd[1] |= CRYPTO_PRNG_KSCTL_ECDH_Msk;
	else if (is_ecdsa)
		req.cmd[1] |= CRYPTO_PRNG_KSCTL_ECDSA_Msk;

	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret == 0)
		*key_num = req.ack[1];
	return 0;
}


/**
  * @brief    Configure AES encrypt/decrypt mode.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  kinswap       1: Swap key and initial vector
  *                           0: MA35D1 not swap key and initial vector
  * @param[in]  koutswap      1: Swap feedback output
  *                           0: MA35D1 not swap AES feedback output
  * @param[in]  inswap        1: Swap input data
  *                           0: MA35D1 not swap input data
  * @param[in]  outswap       1: Swap output data
  *                           0: MA35D1 not swap output data
  * @param[in]  sm4en         1: Use SM4 cipher
  *                           0: Use AES cipher
  * @param[in]  encrypt       1: Execute encrypt operation
  *                           0: Execute decrypt operation
  * @param[in]  mode          Operation mode
  *                           - \ref AES_MODE_ECB
  *                           - \ref AES_MODE_CBC
  *                           - \ref AES_MODE_CFB
  *                           - \ref AES_MODE_OFB
  *                           - \ref AES_MODE_CTR
  *                           - \ref AES_MODE_CBC_CS1
  *                           - \ref AES_MODE_CBC_CS2
  *                           - \ref AES_MODE_CBC_CS3
  *                           - \ref AES_MODE_GCM
  *                           - \ref AES_MODE_GHASH
  *                           - \ref AES_MODE_CCM
  * @param[in]  keysz         Key size
  *                           - \ref AES_KEY_SIZE_128
  *                           - \ref AES_KEY_SIZE_192
  *                           - \ref AES_KEY_SIZE_256
  * @param[in]  ks            Key source
  *                           SEL_KEY_FROM_REG:      Key is assigned by AES_Set_Key command
  *                           SEL_KEY_FROM_KS_SRAM:  Key is from TSI Key Store SRAM
  *                           SEL_KEY_FROM_KS_OTP:   Key is from TSI Key Store OTP
  * @param[in]  ks_num        Key Store key number
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_AES_Set_Mode(int sid, int kinswap, int koutswap, int inswap, int outswap, int sm4en,
					 int encrypt, int mode, int keysz, int ks, int ks_num)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_SET_MODE << 16) | sid;
	req.cmd[1] = (kinswap << 25) | (koutswap << 24) | (inswap << 23) | (outswap << 22) |
				 (sm4en << 17) | (encrypt << 16) | (mode << 8) | (keysz << 2);
	req.cmd[2] = (ks<<5) | ks_num;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Set AES/SM4 initial vector.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  iv_addr       Address of the buffer for initial vector
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_AES_Set_IV(int sid, uint32_t iv_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_SET_IV << 16) | sid;
	req.cmd[1] = iv_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Set AES/SM4 Keys.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  keysz         Key size
  *                           - \ref AES_KEY_SIZE_128
  *                           - \ref AES_KEY_SIZE_192
  *                           - \ref AES_KEY_SIZE_256
  * @param[in]  key_addr       Address of the buffer for AES/SM4 key
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_AES_Set_Key(int sid, int keysz, uint32_t key_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_SET_KEY << 16) | sid;
	if (keysz == AES_KEY_SIZE_128)
		req.cmd[1] = 4;
	else if (keysz == AES_KEY_SIZE_192)
		req.cmd[1] = 6;
	else
		req.cmd[1] = 8;
	req.cmd[2] = key_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Start AES encrypt/decrypt.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  is_last       1: Is the last run of this AES/SM4 session.
  *                           0: Is not the last session.
  * @param[in]  data_cnt      AES/SM4 encrypt/decrypt data count in bytes
  *                           - \ref AES_KEY_SIZE_128
  *                           - \ref AES_KEY_SIZE_192
  *                           - \ref AES_KEY_SIZE_256
  * @param[in]  src_addr      DMA input data address
  * @param[in]  dest_addr     DMA output data address
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_AES_Run(int sid, int is_last, int data_cnt, uint32_t src_addr, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_RUN << 16) | sid;
	req.cmd[1] = (is_last << 24) | data_cnt;
	req.cmd[2] = src_addr;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Start AES GCM mode encrypt/decrypt.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  is_last       1: Is the last run of this AES/SM4 session.
  *                           0: Is not the last session.
  * @param[in]  data_cnt      AES/SM4 encrypt/decrypt data count in bytes
  *                           - \ref AES_KEY_SIZE_128
  *                           - \ref AES_KEY_SIZE_192
  *                           - \ref AES_KEY_SIZE_256
  * @param[in]  param_addr    Address of the parameter block
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_AES_GCM_Run(int sid, int is_last, int data_cnt, uint32_t param_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_GCM_RUN << 16) | sid;
	req.cmd[1] = (is_last << 24) | data_cnt;
	req.cmd[2] = param_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Read or write AES/SM4 intermediate feedback data.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  rw            1: write feedback data
  *                           0: read feedback data
  * @param[in]  wcnt          Word count of feedback data
  * @param[in]  fdbck_addr    Feedback data address
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_Access_Feedback(int sid, int rw, int wcnt, uint32_t fdbck_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_AES_ACCESS_FEEDBACK << 16) | sid;
	req.cmd[1] = (rw<<7) | wcnt;
	req.cmd[2] = fdbck_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Start to process the first block of a SHA session.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  inswap        1: Swap input data
  *                           0: MA35D1 not swap input data
  * @param[in]  outswap       1: Swap output data
  *                           0: MA35D1 not swap output data
  * @param[in]  mode_sel      SHA engine mode
  *                           - \ref SHA_MODE_SEL_SHA1
  *                           - \ref SHA_MODE_SEL_SHA2
  *                           - \ref SHA_MODE_SEL_SHA3
  *                           - \ref SHA_MODE_SEL_SM3
  *                           - \ref SHA_MODE_SEL_MD5
  * @param[in]  hmac          1: Use HMAC key
  *                           0: No HMAC
  * @param[in]  mode          Operation mode
  *                           - \ref SHA_MODE_SHA1
  *                           - \ref SHA_MODE_SHA224
  *                           - \ref SHA_MODE_SHA256
  *                           - \ref SHA_MODE_SHA384
  *                           - \ref SHA_MODE_SHA512
  *                           - \ref SHA_MODE_SHAKE128
  *                           - \ref SHA_MODE_SHAKE256
  * @param[in]  keylen        HMAC key length in bytes. Only effective when "hmac" is 1.
  * @param[in]  ks            Key source
  *                           SEL_KEY_FROM_REG:      HMAC key is from TSI_SHA_Update() data
  *                           SEL_KEY_FROM_KS_SRAM:  HMAC key is from TSI Key Store SRAM
  *                           SEL_KEY_FROM_KS_OTP:   HMAC key is from TSI Key Store OTP
  * @param[in]  ks_num        Key Store key number
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_SHA_Start(int sid, int inswap, int outswap, int mode_sel, int hmac,
					 int mode, int keylen, int ks, int ks_num)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_SHA_START << 16) | sid;
	req.cmd[1] = (inswap << 23) | (outswap << 22) | (mode_sel << 12) |
				 (hmac << 11) | (mode << 8);
	req.cmd[2] = keylen;
	req.cmd[3] = (ks << 5) | ks_num;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Update SHA data.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  data_cnt      byte count of input data
  * @param[in]  src_addr      Address of input data
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_SHA_Update(int sid, int data_cnt, uint32_t src_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_SHA_UPDATE << 16) | sid;
	req.cmd[1] = data_cnt;
	req.cmd[2] = src_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}


/**
  * @brief    Update the last block of data and get result digest.
  * @param[in]  sid           The session ID obtained from TSI_Open_Session().
  * @param[in]  wcnt          Word count of output digest
  * @param[in]  data_cnt      Byte count of input data
  * @param[in]  src_addr      Address of input data
  * @param[in]  dest_addr     Address of output digest
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_SHA_Finish(int sid, int wcnt, int data_cnt, uint32_t src_addr, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_SHA_FINISH << 16) | sid;
	req.cmd[1] = (wcnt << 24) | data_cnt;
	req.cmd[2] = src_addr;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Run SHA all at once.
  * @param[in]  inswap        1: Swap input data
  *                           0: MA35D1 not swap input data
  * @param[in]  outswap       1: Swap output data
  *                           0: MA35D1 not swap output data
  * @param[in]  mode_sel      SHA engine mode
  *                           - \ref SHA_MODE_SEL_SHA1
  *                           - \ref SHA_MODE_SEL_SHA2
  *                           - \ref SHA_MODE_SEL_SHA3
  *                           - \ref SHA_MODE_SEL_SM3
  *                           - \ref SHA_MODE_SEL_MD5
  * @param[in]  mode          Operation mode
  *                           - \ref SHA_MODE_SHA1
  *                           - \ref SHA_MODE_SHA224
  *                           - \ref SHA_MODE_SHA256
  *                           - \ref SHA_MODE_SHA384
  *                           - \ref SHA_MODE_SHA512
  *                           - \ref SHA_MODE_SHAKE128
  *                           - \ref SHA_MODE_SHAKE256
  * @param[in]  wcnt          Word count of output digest
  * @param[in]  data_cnt      Byte count of input data
  * @param[in]  src_addr      Address of input data
  * @param[in]  dest_addr     Address of output digest
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_SHA_All_At_Once(int inswap, int outswap, int mode_sel, int mode,
						int wcnt, int data_cnt, uint32_t src_addr, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_SHA_ALL_AT_ONCE << 16) | ((data_cnt >> 8) & 0xffff);
	req.cmd[1] = ((data_cnt & 0xff) << 24) | (inswap << 23) | (outswap << 22) |
				 (mode_sel << 12) | (mode << 8) | wcnt;
	req.cmd[2] = src_addr;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Generate an ECC public key.
  * @param[in]  curve_id      ECC curve ID
  * @param[in]  is_ecdh       Only used when psel is ECC_KEY_SEL_KS_SRAM.
  *                           0: is not ECDH key.
  *                           1: is ECDH key.
  * @param[in]  psel          Select private key source
  *                           - \ref ECC_KEY_SEL_TRNG    : Private key is generated by TRNG
  *                           - \ref ECC_KEY_SEL_KS_OTP  : Private Key is from Key Store OTP
  *                           - \ref ECC_KEY_SEL_KS_SRAM : Private Key is from Key Store SRAM
  *                           - \ref ECC_KEY_SEL_USER    : User defined private key
  * @param[in]  d_knum        The Key Store key index. Effective only when "psel" is 0x01 or 0x02.
  * @param[in]  priv_key      Address of input private key. Effective only when "psel" is 0x03.
  * @param[in]  pub_key       Address of the output public key.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_ECC_GenPublicKey(E_ECC_CURVE curve_id, int is_ecdh, int psel, int d_knum, uint32_t priv_key, uint32_t pub_key)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_ECC_GEN_PUB_KEY << 16) | curve_id;
	req.cmd[1] = (is_ecdh << 10) | (psel << 8) | d_knum;
	req.cmd[2] = priv_key;
	req.cmd[3] = pub_key;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Generate an ECC signature.
  * @param[in]  curve_id      ECC curve ID
  * @param[in]  rsel          0: Random number is generated by TSI TRNG
  *                           1: Use the random number specified in parameter block.
  * @param[in]  psel          Select private key source
  *                           - \ref ECC_KEY_SEL_TRNG    : Private key is generated by TRNG
  *                           - \ref ECC_KEY_SEL_KS_OTP  : Private Key is from Key Store OTP
  *                           - \ref ECC_KEY_SEL_KS_SRAM : Private Key is from Key Store SRAM
  *                           - \ref ECC_KEY_SEL_USER    : User defined private key
  * @param[in]  d_knum        The Key Store key index. Effective only when "psel" is 0x01 or 0x02.
  * @param[in]  param_addr    Address of the input parameter block, including message and private key.
  *                           The private key in parameter block is effective only when "psel" is 0x03.
  * @param[in]  sig_addr      Address of the output signature.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_ECC_GenSignature(E_ECC_CURVE curve_id, int rsel, int psel, int d_knum, uint32_t param_addr, uint32_t sig_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_ECC_GEN_SIG << 16) | curve_id;
	req.cmd[1] = (rsel << 10) | (psel << 8) | d_knum;
	req.cmd[2] = param_addr;
	req.cmd[3] = sig_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Verify if an ECC signature valid or not.
  * @param[in]  curve_id      ECC curve ID
  * @param[in]  psel          Select public key source
  *                           - \ref ECC_KEY_SEL_KS_OTP  : Private Key is from Key Store OTP
  *                           - \ref ECC_KEY_SEL_KS_SRAM : Private Key is from Key Store SRAM
  *                           - \ref ECC_KEY_SEL_USER    : User defined private key
  * @param[in]  x_knum        The Key Store key number of public key X. Effective only when "psel" is 0x01 or 0x02.
  * @param[in]  y_knum        The Key Store key number of public key Y. Effective only when "psel" is 0x01 or 0x02.
  * @param[in]  param_addr    Address of the input parameter block.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_ECC_VerifySignature(E_ECC_CURVE curve_id, int psel, int x_knum, int y_knum, uint32_t param_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_ECC_VERIFY_SIG << 16) | curve_id;
	req.cmd[1] = (psel << 16) | (y_knum << 8) | x_knum;
	req.cmd[2] = param_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Execute ECC point multiplication.
  * @param[in]  curve_id      ECC curve ID
  * @param[in]  type          Type of multipler k. 0x1: is ECDH key
  * @param[in]  msel          Select the source of multiplier
  *                           - 0x1: Multiplier is from Key Store OTP
  *                           - 0x2: Multiplier is from Key Store SRAM
  *                           - 0x3: Multiplier is from parameter block
  * @param[in]  sps           Select the source of input point
  *                           - 0x1: Input point is from Key Store OTP
  *                           - 0x2: Input point is from Key Store SRAM
  *                           - 0x3: Input point is from parameter block
  * @param[in]  m_knum        The Key Store key number of multiplier. Used only when "msel" is 0x01 or 0x02.
  * @param[in]  x_knum        The Key Store key number of input point X. Effective only when "msel" is 0x01 or 0x02.
  * @param[in]  y_knum        The Key Store key number of input point Y. Effective only when "msel" is 0x01 or 0x02.
  * @param[in]  param_addr    Address of the input parameter block.
  * @param[in]  dest_addr     Address of the output ECC point.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_ECC_Multiply(E_ECC_CURVE curve_id, int type, int msel, int sps, int m_knum, int x_knum, int y_knum,
						uint32_t param_addr, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_ECC_MULTIPLY << 16) | curve_id;
	req.cmd[1] = (type << 28) | (msel << 26) | (sps << 24) | (m_knum << 16) |
				 (x_knum << 8) | (y_knum);
	req.cmd[2] = param_addr;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief    Execute RSA exponent modulus.
  * @param[in]  rsa_len       RSA bit length
  *                           - 0: 1024 bits
  *                           - 1: 2048 bits
  *                           - 2: 3072 bits
  *                           - 3: 4096 bits
  * @param[in]  crt           0: disable CRT; 1: enable CRT
  * @param[in]  esel          Select private key source
  *                           - \ref RSA_KEY_SEL_KS_OTP  : Exponent of exponentiation is from Key Store OTP
  *                           - \ref RSA_KEY_SEL_KS_SRAM : Exponent of exponentiation is from Key Store SRAM
  *                           - \ref RSA_KEY_SEL_USER    : Exponent of exponentiation is from input parameter block
  * @param[in]  e_knum        The Key Store key number of RSA exponent E. Used only when "esel" is RSA_KEY_SEL_KS_OTP or RSA_KEY_SEL_KS_SRAM.
  * @param[in]  param_addr    Address of the input parameter block.
  * @param[in]  dest_addr     Address of the output data.
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_RSA_Exp_Mod(int rsa_len, int crt, int esel, int e_knum, uint32_t param_addr, uint32_t dest_addr)
{
	TSI_REQ_T  req;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_EXT_RSA_EXP_MOD << 16) | rsa_len;
	req.cmd[1] = (crt<<10) | (esel<<8) | e_knum;
	req.cmd[2] = param_addr;
	req.cmd[3] = dest_addr;
	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
}

/**
  * @brief      Write key to key store SRAM
  * @param[in]  u32Meta     The metadata of the key. It could be the combine of
								\ref KS_META_AES
								\ref KS_META_HMAC
								\ref KS_META_RSA_EXP
								\ref KS_META_RSA_MID
								\ref KS_META_ECC
								\ref KS_META_CPU
								\ref KS_META_128
								\ref KS_META_163
								\ref KS_META_192
								\ref KS_META_224
								\ref KS_META_233
								\ref KS_META_255
								\ref KS_META_256
								\ref KS_META_283
								\ref KS_META_384
								\ref KS_META_409
								\ref KS_META_512
								\ref KS_META_521
								\ref KS_META_571
								\ref KS_META_1024
								\ref KS_META_2048
								\ref KS_META_4096
								\ref KS_META_READABLE
								\ref KS_META_PRIV
								\ref KS_META_NONPRIV
								\ref KS_META_SECURE
  * @param[out] au32Key       The buffer to store the key
  * @param[in]  iKeyNum       The SRAM key number which the key was written to
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_Write_SRAM(uint32_t u32Meta, uint32_t au32Key[], int *iKeyNum)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_WRITE_SRAM_KEY << 16);
	req.cmd[1] = u32Meta;
	req.cmd[2] = ptr_to_u32(au32Key);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*iKeyNum = req.ack[1];
	return ret;
}

/**
  * @brief      Write key to key store OTP
  * @param[in]  KeyNum       Key number of the OTP key to write
  * @param[in]  u32Meta      The metadata of the key. It could be the combine of
								\ref KS_META_AES
								\ref KS_META_HMAC
								\ref KS_META_RSA_EXP
								\ref KS_META_RSA_MID
								\ref KS_META_ECC
								\ref KS_META_CPU
								\ref KS_META_128
								\ref KS_META_163
								\ref KS_META_192
								\ref KS_META_224
								\ref KS_META_233
								\ref KS_META_255
								\ref KS_META_256
								\ref KS_META_283
								\ref KS_META_384
								\ref KS_META_409
								\ref KS_META_512
								\ref KS_META_521
								\ref KS_META_571
								\ref KS_META_1024
								\ref KS_META_2048
								\ref KS_META_4096
								\ref KS_META_READABLE
								\ref KS_META_PRIV
								\ref KS_META_NONPRIV
								\ref KS_META_SECURE
  * @param[out] au32Key       The buffer to store the key
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_Write_OTP(int KeyNum, uint32_t u32Meta, uint32_t au32Key[])
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_WRITE_OTP_KEY << 16);
	req.cmd[1] = u32Meta;
	req.cmd[2] = ptr_to_u32(au32Key);
	req.cmd[3] = KeyNum;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief      Read key from key store
  * @param[in]  eType       The memory type. It could be:
							\ref KS_SRAM
							\ref KS_OTP
  * @param[in]  i32KeyIdx   The key index to read
  * @param[out] au32Key     The buffer to store the key
  * @param[in]  u32WordCnt  The word (32-bit) count of the key buffer size
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_Read(KS_MEM_Type eType, int32_t i32KeyIdx, uint32_t au32Key[], uint32_t u32WordCnt)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_READ_KEY << 16);
	req.cmd[1] = (eType << 30) | (u32WordCnt << 8) | i32KeyIdx;
	req.cmd[2] = ptr_to_u32(au32Key);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief      Revoke a key in key store
  * @param[in]  eType         The memory type. It could be:
							  \ref KS_SRAM
							  \ref KS_OTP
  * @param[in]  i32KeyIdx     The key index to read
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_RevokeKey(KS_MEM_Type eType, int32_t i32KeyIdx)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_REVOKE_KEY << 16);
	req.cmd[1] = (eType << 30) | i32KeyIdx;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief      Erase a key from key store
  * @param[in]    eType       The memory type. It could be:
							  \ref KS_SRAM
							  \ref KS_OTP
  * @param[in]  i32KeyIdx     The key index to erase
  * @return   0               success
  * @return   otherwise       error code from TSI
   */
int  TSI_KS_EraseKey(KS_MEM_Type eType, int32_t i32KeyIdx)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_ERASE_KEY << 16);
	req.cmd[1] = (eType << 30) | i32KeyIdx;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief    Erase all keys from Key Store SRAM
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_EraseAll(void)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_ERASE_ALL << 16);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/**
  * @brief      Get remain size of Key Store SRAM
  * @param[in]  remain_size   Remain size of KS_SRAM
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_GetRemainSize(int *remain_size)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_REMAIN_SIZE << 16);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*remain_size = req.ack[1];
	return ret;
}

/**
  * @brief       Get status of Key Store
  * @param[out]  ks_sts       content of KS_STS register
  * @param[out]  ks_otpsts    content of KS_OTPSTS register
  * @param[out]  ks_metadata  content of KS_METADATA register
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_KS_GetStatus(uint32_t *ks_sts, uint32_t *ks_otpsts, uint32_t *ks_metadata)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_KS_GET_STATUS << 16);
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*ks_sts = req.ack[1];
	*ks_otpsts = req.ack[2];
	*ks_metadata = req.ack[3];
	return ret;
}

/**
  * @brief      Read key data from OTP
  * @param[in]  u32Addr       The OTP address
  * @param[out] u32Data       The data read from OTP
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_OTP_Read(uint32_t u32Addr, uint32_t *u32Data)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_EXT_OTP_READ << 16);
	req.cmd[1] = u32Addr;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	*u32Data = req.ack[1];
	return ret;
}

/**
  * @brief      Program key data to OTP
  * @param[in]  u32Addr       The OTP address
  * @param[out] u32Data       The data read to be written to OTP
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int  TSI_OTP_Program(uint32_t u32Addr, uint32_t u32Data)
{
	TSI_REQ_T  req;
	int  ret;

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (CMD_EXT_OTP_PROGRAM << 16);
	req.cmd[1] = u32Addr;
	req.cmd[2] = u32Data;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	return ret;
}

/// @cond HIDDEN_SYMBOLS

__aligned(64) static unsigned char tsi_patch_image[] = {
	0x61, 0xc3, 0x66, 0xe4, 0x7a, 0x7a, 0x1b, 0x05, 0x2b, 0x43, 0x44, 0xc8, 0xe1, 0x40, 0x40, 0x74,
	0x44, 0xe8, 0x85, 0xa2, 0x72, 0x53, 0xda, 0xa5, 0xd8, 0x9a, 0xa3, 0xd7, 0x35, 0x72, 0xce, 0x66,
	0x09, 0x7c, 0xa3, 0x07, 0x59, 0x29, 0x30, 0x7d, 0x33, 0xcd, 0x80, 0x29, 0xcd, 0xfd, 0x38, 0x28,
	0x48, 0x4a, 0xe2, 0x73, 0x99, 0x13, 0x61, 0xc2, 0x96, 0xc8, 0x65, 0xb0, 0xb2, 0xb9, 0x7a, 0x48,
	0x90, 0x5e, 0x9c, 0xf2, 0x5f, 0x70, 0x78, 0xf1, 0xfd, 0xc6, 0x63, 0x4e, 0x23, 0x72, 0x92, 0xa7,
	0x16, 0x0d, 0x7e, 0x90, 0xe0, 0x7d, 0x65, 0x49, 0x7d, 0x3a, 0x79, 0x22, 0x52, 0x1e, 0x43, 0x18,
	0x4a, 0xf2, 0x19, 0xfe, 0xee, 0xf0, 0x39, 0x5a, 0x87, 0x9c, 0xa8, 0x71, 0x17, 0xc6, 0x7a, 0x12,
	0x37, 0x2d, 0xe6, 0x89, 0x85, 0xe8, 0xbb, 0xac, 0x1f, 0x18, 0x22, 0xbc, 0xf6, 0xd6, 0x56, 0x06,
	0xbe, 0xb1, 0x5a, 0x65, 0xe9, 0xce, 0x66, 0x4b, 0xd5, 0x53, 0x1f, 0xbf, 0xb2, 0x80, 0x81, 0x32,
	0xd3, 0x3f, 0x7e, 0x24, 0x21, 0x6c, 0x72, 0x2b, 0x3b, 0x95, 0x02, 0x20, 0x80, 0xc6, 0x93, 0x26,
	0x0b, 0x44, 0x02, 0x2d, 0x8e, 0x00, 0x31, 0x1e, 0x08, 0x88, 0x09, 0xbe, 0x7d, 0x41, 0x39, 0x77,
	0x72, 0x9c, 0x73, 0x75, 0x85, 0x8e, 0x0f, 0x25, 0x86, 0xe7, 0x80, 0xad, 0x7a, 0x94, 0xca, 0x10,
	0xa8, 0x14, 0xc6, 0x94, 0x95, 0xa5, 0xfb, 0xd9, 0x3a, 0x7d, 0x10, 0x49, 0xad, 0xc7, 0x76, 0x0b,
	0x90, 0x7f, 0x6d, 0x94, 0xe0, 0xa8, 0x40, 0xd9, 0x2e, 0x8d, 0x36, 0x89, 0xc2, 0x30, 0x90, 0xe9,
	0x06, 0x45, 0x12, 0x89, 0xef, 0x12, 0x42, 0x8a, 0x08, 0x9b, 0xad, 0xe0, 0x48, 0x28, 0x07, 0x46,
	0xf7, 0x82, 0xc9, 0x48, 0x90, 0x1b, 0xc1, 0x2c, 0xae, 0x7c, 0xd1, 0x59, 0x48, 0x40, 0xd3, 0xe7,
	0x3f, 0x87, 0x9d, 0x0b, 0xcf, 0x7c, 0x43, 0xd2, 0x54, 0x58, 0x7c, 0x5a, 0x68, 0x60, 0x05, 0x90,
	0x12, 0x49, 0xf5, 0x6b, 0xf5, 0xe0, 0xab, 0xd9, 0x2b, 0xd6, 0xfa, 0x71, 0xd8, 0xe4, 0x80, 0xc4,
	0xf4, 0x88, 0x5f, 0x35, 0x9b, 0xfd, 0xf3, 0x53, 0x39, 0x79, 0x39, 0xe6, 0xcc, 0x8b, 0x06, 0x99,
	0x38, 0xc0, 0x77, 0xc6, 0xbc, 0xd0, 0x43, 0x61, 0x7d, 0x90, 0x73, 0x14, 0x85, 0xa6, 0x32, 0x13,
	0x7c, 0x61, 0x60, 0x9e, 0x9a, 0x17, 0x3e, 0x52, 0x53, 0xcb, 0xe6, 0xd3, 0x67, 0x39, 0xd4, 0x53,
	0x00, 0x53, 0xb8, 0x1b, 0x04, 0x9d, 0x67, 0x5c, 0x9b, 0x35, 0xf2, 0x28, 0x90, 0x12, 0x36, 0x3a,
	0xb8, 0xdd, 0x75, 0x54, 0x29, 0xed, 0x1c, 0xfd, 0x8b, 0xd7, 0x39, 0x6d, 0x0a, 0xcb, 0x0c, 0x7c,
	0x40, 0xa5, 0x9a, 0x99, 0xfa, 0x59, 0x0d, 0xb9, 0x13, 0xd7, 0x26, 0x8f, 0x87, 0x68, 0x34, 0x54,
	0x96, 0x1e, 0x98, 0x9f, 0xce, 0xe5, 0x05, 0x7f, 0x56, 0x99, 0x9b, 0x24, 0xaa, 0x71, 0xde, 0x3c,
	0x7b, 0x65, 0x58, 0x44, 0x60, 0xc7, 0xf7, 0x34, 0x3b, 0xf5, 0xbb, 0xd0, 0x78, 0x41, 0x98, 0x38,
	0x20, 0xb0, 0x73, 0x33, 0xa6, 0x2b, 0x19, 0xfa, 0x88, 0xad, 0x63, 0x94, 0x06, 0xc2, 0xea, 0x9d,
	0xcd, 0x37, 0x23, 0x60, 0xf7, 0xb3, 0x43, 0x2e, 0xea, 0xd4, 0x5b, 0x49, 0x76, 0xff, 0x5e, 0xdc,
	0x02, 0xa0, 0x6f, 0x61, 0xaa, 0xd9, 0xb3, 0x82, 0xcd, 0xcd, 0xbb, 0x1a, 0x84, 0x28, 0x28, 0x1f,
	0x29, 0x17, 0x85, 0x5e, 0x05, 0x18, 0xbf, 0xdd, 0xf6, 0xcf, 0x73, 0xcd, 0xd6, 0x69, 0x98, 0x3e,
	0x91, 0x90, 0x40, 0x85, 0xb5, 0x89, 0x01, 0x9f, 0xd0, 0x1e, 0xfd, 0xf2, 0xde, 0xfd, 0x1b, 0x18,
	0x5e, 0x1d, 0x72, 0xd8, 0xcd, 0x8e, 0x29, 0xbf, 0x60, 0x49, 0x53, 0x71, 0x81, 0xd1, 0x54, 0x9f,
	0xb9, 0xa1, 0x60, 0xa8, 0x97, 0xaf, 0x9d, 0x7d, 0x13, 0x4f, 0xe4, 0x3d, 0xb0, 0xc6, 0x94, 0x04,
	0xe3, 0xa6, 0xc4, 0x81, 0xc4, 0x22, 0xeb, 0x29, 0x0a, 0xa3, 0x4f, 0x24, 0x31, 0x6c, 0x98, 0xcb,
	0x48, 0x02, 0xa4, 0xc6, 0x86, 0xe6, 0x8a, 0x11, 0x0e, 0xc9, 0xaf, 0x91, 0x50, 0xd0, 0x92, 0x25,
	0x08, 0xcb, 0xd0, 0x88, 0x95, 0x91, 0x3c, 0x58, 0xf2, 0xf4, 0x4a, 0xd6, 0xac, 0x40, 0x90, 0x94,
	0xef, 0x15, 0xa9, 0x5a, 0x1c, 0x98, 0x81, 0xbe, 0xe6, 0xcb, 0x20, 0xe5, 0x9d, 0x84, 0x55, 0x4a,
	0xcf, 0x51, 0x15, 0x77, 0xee, 0x8a, 0x42, 0x1f, 0x64, 0x3b, 0xaf, 0xbd, 0xb3, 0x4a, 0x0d, 0x10,
	0xad, 0xe8, 0x7f, 0xd4, 0xee, 0xa4, 0xf3, 0x6f, 0xf8, 0x44, 0x5b, 0x9a, 0xe5, 0x41, 0xc4, 0xed,
	0x7b, 0xa8, 0xb4, 0xd3, 0x43, 0xf1, 0x56, 0xf7, 0x7a, 0x7e, 0x91, 0x5d, 0x89, 0x99, 0x61, 0xd2,
	0xef, 0x64, 0x1b, 0xf7, 0xbc, 0xfe, 0x44, 0x43, 0x81, 0x5b, 0xff, 0xe2, 0x86, 0xb1, 0x25, 0xbd,
	0xa9, 0x2f, 0xc4, 0xac, 0xd7, 0xfb, 0x79, 0x9b, 0xf1, 0x30, 0xcb, 0xb5, 0x4e, 0x79, 0xc1, 0x47,
	0x53, 0xe8, 0xb8, 0x99, 0xf6, 0xe4, 0xfc, 0x61, 0x0f, 0xb8, 0x0a, 0x5c, 0x08, 0x2d, 0x63, 0xee,
	0x9d, 0x63, 0x36, 0x95, 0xc4, 0xe0, 0xc4, 0x45, 0x6f, 0xb4, 0xcf, 0x7c, 0xb3, 0x29, 0x23, 0xc8,
	0x69, 0x4a, 0xd7, 0x45, 0x1f, 0xd2, 0xa0, 0x5a, 0x89, 0x83, 0x60, 0x5c, 0x4f, 0x71, 0x73, 0x78,
	0x77, 0x22, 0x05, 0xfd, 0xfb, 0xa1, 0x02, 0x62, 0x14, 0x61, 0xfe, 0xd6, 0x06, 0x38, 0x4f, 0x15,
	0xd0, 0x52, 0xfc, 0x90, 0x5b, 0x3b, 0xd5, 0x20, 0x8c, 0x38, 0x61, 0x61, 0x35, 0x1c, 0xee, 0x5e,
	0x6f, 0xb8, 0x52, 0x00, 0x38, 0x5b, 0x75, 0x82, 0x0e, 0x9c, 0xaf, 0x6e, 0x46, 0xdf, 0x8f, 0x0d,
	0x43, 0x00, 0x2c, 0x1c, 0xb8, 0xf2, 0x03, 0x3c, 0x3d, 0x87, 0x01, 0x92, 0x7c, 0xfc, 0x69, 0x3e,
	0xab, 0x54, 0x92, 0x52, 0xe6, 0xad, 0x7b, 0x97, 0x8f, 0xb2, 0x50, 0xde, 0x1e, 0x78, 0x94, 0x36,
	0x05, 0x9d, 0x89, 0x2d, 0x2e, 0x1a, 0xdd, 0x14, 0xf3, 0xf2, 0xb3, 0x76, 0x0d, 0xf9, 0xf5, 0x16,
	0x03, 0x02, 0xf7, 0x3f, 0x81, 0xb2, 0x50, 0xe1, 0x5d, 0xb3, 0x65, 0xde, 0x0a, 0x28, 0xbf, 0xb3,
	0x9d, 0x19, 0xf7, 0x05, 0xa3, 0x3f, 0x3b, 0x6a, 0xf1, 0x69, 0x50, 0xf6, 0x01, 0x2c, 0x34, 0x13,
	0x36, 0x72, 0x1d, 0x20, 0xec, 0x8c, 0x99, 0x87, 0x31, 0x9a, 0x44, 0x99, 0x01, 0x8d, 0xfd, 0x0b,
	0x1c, 0x21, 0x04, 0x46, 0x62, 0xfb, 0x71, 0xc6, 0xe6, 0x92, 0x32, 0xdc, 0x3d, 0x59, 0x37, 0xf8,
	0x6f, 0x37, 0x39, 0x51, 0x87, 0xcc, 0xbe, 0x96, 0xe7, 0x17, 0xca, 0xd9, 0xc5, 0x10, 0x7c, 0x00,
	0x22, 0xb1, 0xe9, 0xdf, 0x3e, 0x4c, 0x37, 0xe9, 0xee, 0xbb, 0x05, 0x13, 0x10, 0xd4, 0x5c, 0x27,
	0x83, 0x78, 0x47, 0x66, 0x41, 0x96, 0xf6, 0x29, 0xad, 0xdb, 0xe3, 0x09, 0x29, 0xa9, 0x7c, 0x72,
	0x75, 0x17, 0xba, 0x68, 0xeb, 0xb4, 0x48, 0xaf, 0x53, 0xb6, 0x66, 0x1c, 0xc5, 0x1b, 0x3b, 0x3c,
	0xed, 0x90, 0xe9, 0xef, 0xf0, 0xd4, 0x2b, 0x8e, 0x83, 0xf5, 0xd2, 0x19, 0x35, 0x3d, 0x96, 0x10,
	0xf1, 0xd8, 0xd2, 0x58, 0x51, 0x49, 0xeb, 0x54, 0x2d, 0x82, 0xfe, 0x06, 0xca, 0x35, 0x15, 0x0b,
	0x74, 0xcc, 0xb4, 0xda, 0x89, 0x28, 0x3c, 0x84, 0x0c, 0x8f, 0xb9, 0xff, 0x5e, 0x3c, 0xcc, 0x5f,
	0x26, 0x46, 0xaf, 0xc3, 0xf6, 0x89, 0x8c, 0xb4, 0xa6, 0x09, 0xc7, 0x78, 0xce, 0xff, 0x24, 0x83,
	0xdc, 0xa8, 0xe8, 0x63, 0xa1, 0xdc, 0x37, 0xf1, 0x92, 0x05, 0x45, 0xdf, 0x6c, 0x4d, 0x98, 0xce,
	0xdc, 0xc8, 0x96, 0x79, 0xeb, 0x0b, 0x39, 0x35, 0x76, 0x8f, 0xcb, 0x19, 0xf8, 0xb7, 0x37, 0x93,
	0x84, 0x00, 0x93, 0x59, 0x66, 0x09, 0x86, 0x12, 0x9c, 0x97, 0x3a, 0x61, 0x46, 0xd7, 0x5e, 0x5a,
	0xc4, 0xac, 0x9e, 0x3e, 0x41, 0x67, 0x08, 0x44, 0x45, 0x0f, 0x0d, 0x69, 0x52, 0x4e, 0x9f, 0x7e,
	0x21, 0x61, 0x5f, 0xc1, 0x6b, 0x5f, 0x1b, 0xdd, 0xbb, 0x09, 0x9a, 0xba, 0x84, 0xbe, 0x76, 0x09,
	0xf5, 0xb7, 0x5f, 0x52, 0x27, 0x5f, 0x01, 0x52, 0xb2, 0xfa, 0xaa, 0x1e, 0x86, 0x0a, 0x29, 0x0d,
	0x51, 0x3e, 0x25, 0xf0, 0xc8, 0x8e, 0x66, 0x54, 0x1f, 0x97, 0x34, 0xab, 0xc1, 0xfc, 0xfc, 0x04,
	0x4e, 0xfa, 0x44, 0x94, 0xcd, 0x30, 0xc3, 0x2d, 0xdf, 0x56, 0x97, 0x95, 0x51, 0xef, 0x09, 0x73,
	0xab, 0xba, 0x08, 0x74, 0x10, 0x90, 0xa3, 0x9c, 0xe9, 0xe6, 0xdb, 0x3c, 0xa1, 0xd1, 0x7e, 0xdf,
	0x4c, 0x20, 0x15, 0x79, 0xe9, 0x05, 0x0f, 0xe3, 0x9b, 0xc7, 0x0c, 0xc9, 0x17, 0x9b, 0xf8, 0xb2,
	0xbb, 0x50, 0x51, 0xd5, 0x0f, 0xad, 0xd5, 0x81, 0x93, 0x47, 0xa1, 0x02, 0xbb, 0x77, 0x26, 0x51,
	0x9c, 0xd8, 0x35, 0x94, 0x7d, 0x95, 0x81, 0xb1, 0x1b, 0xbc, 0x13, 0x78, 0x6b, 0xe8, 0xd6, 0x6f,
	0x6a, 0x10, 0x16, 0xe3, 0xbc, 0xd2, 0x34, 0x05, 0xbf, 0x76, 0xf0, 0x11, 0xe2, 0xec, 0x2f, 0x32,
	0x8f, 0x1f, 0xda, 0x5c, 0x73, 0x89, 0x56, 0x61, 0xc0, 0x5e, 0xe2, 0x73, 0x2a, 0xa9, 0x66, 0xf6,
	0xa0, 0xe5, 0x31, 0xd8, 0xb8, 0xad, 0xe9, 0xb2, 0xea, 0xe3, 0xcd, 0x04, 0xb3, 0x3f, 0xdd, 0x49,
	0x07, 0x1b, 0x72, 0x46, 0xd4, 0x4f, 0x1e, 0x4a, 0x8a, 0x7d, 0x81, 0xb1, 0xd1, 0x77, 0x22, 0xba,
	0x81, 0xfd, 0x5f, 0x8c, 0x50, 0xd2, 0xd5, 0x8e, 0xc2, 0x2d, 0x43, 0x59, 0xb1, 0x12, 0xb2, 0x7f,
	0x1c, 0xb4, 0x3d, 0x26, 0xa6, 0xfe, 0xfb, 0x97, 0x42, 0xd0, 0xfb, 0x96, 0xb0, 0xc2, 0x17, 0x07,
	0x53, 0x7d, 0x7d, 0x52, 0x87, 0x46, 0x19, 0x47, 0xa3, 0xa4, 0x63, 0xf0, 0x9e, 0xf1, 0x35, 0xc7,
	0xe5, 0x84, 0x92, 0xb5, 0xe6, 0xc8, 0xb1, 0xeb, 0xfa, 0xcf, 0xd3, 0x7b, 0x3e, 0xea, 0xf2, 0x1d,
	0xf8, 0x7f, 0xab, 0x67, 0x5c, 0x8d, 0xf4, 0xff, 0x73, 0x07, 0xc1, 0x10, 0xfa, 0xf4, 0xf1, 0x97,
	0x3a, 0xd0, 0x11, 0xe9, 0xd7, 0x8c, 0x2b, 0x35, 0x5a, 0xd1, 0x27, 0xe0, 0x1e, 0x1f, 0x51, 0xc9,
	0x52, 0x04, 0x6d, 0x69, 0xfc, 0x76, 0x2e, 0xca, 0x7a, 0xe7, 0x52, 0x50, 0x55, 0xd5, 0x28, 0xee,
	0x4b, 0xa5, 0xf9, 0x6c, 0x38, 0xef, 0x5b, 0x1d, 0xf9, 0xc0, 0x3e, 0x94, 0x5d, 0x61, 0xfd, 0x82,
	0xd5, 0x1e, 0x68, 0x6f, 0xdd, 0x05, 0x14, 0x08, 0x4f, 0x66, 0xdc, 0x1e, 0xa5, 0x14, 0x4c, 0x3a,
	0x4d, 0xfe, 0xf4, 0x05, 0xec, 0x29, 0x48, 0x90, 0xd8, 0xfb, 0x05, 0x5c, 0xca, 0x32, 0x00, 0x27,
	0xf4, 0xa2, 0x23, 0xba, 0x9c, 0x91, 0xdb, 0x44, 0xf7, 0x78, 0x23, 0x3b, 0x44, 0x7b, 0x3e, 0xe3,
	0xc3, 0xf9, 0x0e, 0xdc, 0x3f, 0xbb, 0xde, 0x63, 0x88, 0x64, 0x9a, 0x7f, 0xdb, 0xf0, 0x31, 0x75,
	0x1d, 0x6d, 0xdf, 0x6c, 0xf7, 0xda, 0x01, 0x07, 0x3d, 0x8b, 0x9b, 0x73, 0x89, 0xa5, 0xce, 0x50,
	0x51, 0x2b, 0xee, 0xc6, 0x2c, 0xe5, 0xd1, 0xda, 0x05, 0x27, 0x7e, 0x4c, 0xdf, 0x6d, 0xbb, 0x17,
	0xe8, 0xed, 0xcf, 0x94, 0x6c, 0xa9, 0xc0, 0x2b, 0xd1, 0xc8, 0xb7, 0x73, 0x8e, 0xbf, 0x36, 0x62,
	0xf9, 0xa2, 0x2b, 0x3e, 0x6d, 0x81, 0xc4, 0xd6, 0xe6, 0x08, 0x32, 0xfd, 0x83, 0x8e, 0x00, 0xd6,
	0x20, 0x83, 0x03, 0x61, 0x04, 0xa3, 0xfd, 0xb8, 0x7b, 0x1e, 0xf1, 0x2b, 0x4a, 0x6c, 0x54, 0xdc,
	0x7e, 0x91, 0xb3, 0x0f, 0xc8, 0x6a, 0x94, 0xfc, 0xb0, 0x75, 0x09, 0xea, 0x9c, 0xf9, 0x24, 0x8d,
	0x25, 0x16, 0xd3, 0x5e, 0x97, 0x75, 0x27, 0xef, 0xde, 0x32, 0xc2, 0xe6, 0x6b, 0x35, 0xb4, 0xf4,
	0xc7, 0xc5, 0x5a, 0x2a, 0x75, 0x71, 0x5f, 0xfa, 0x12, 0x1d, 0xcd, 0x41, 0x20, 0xa5, 0xdb, 0x8c,
	0xba, 0x11, 0x6f, 0xbd, 0x63, 0xf9, 0x1b, 0xa4, 0x7c, 0xc8, 0x38, 0x7b, 0xd4, 0x1a, 0x96, 0xf1,
	0x9d, 0xec, 0x4e, 0xce, 0x77, 0xdd, 0x56, 0xf2, 0x57, 0x28, 0xde, 0xdc, 0xee, 0x2e, 0xf4, 0xa3,
	0xbf, 0x7e, 0x65, 0x23, 0xfc, 0x09, 0x80, 0xb9, 0x05, 0x59, 0xd1, 0x3b, 0xe0, 0x7a, 0x97, 0xce,
	0x78, 0x1c, 0x6d, 0xf5, 0x85, 0x2c, 0xa8, 0x01, 0x40, 0xa6, 0x31, 0x56, 0x7a, 0x6a, 0xb9, 0x79,
	0xd9, 0x07, 0xda, 0x70, 0x99, 0x79, 0xbc, 0x83, 0xad, 0x7e, 0x17, 0xb9, 0xa7, 0x3e, 0x35, 0xa8,
	0x65, 0xa1, 0x05, 0x56, 0xff, 0xfb, 0x00, 0x47, 0xc0, 0x4e, 0xdf, 0x06, 0xd3, 0x35, 0x89, 0x34,
	0x9a, 0x88, 0xd0, 0x8c, 0x03, 0x4b, 0xe5, 0xdc, 0xaa, 0x18, 0x90, 0xf7, 0x23, 0xaf, 0xfd, 0x81,
	0x7f, 0x08, 0x1e, 0xb7, 0x57, 0xd0, 0x5c, 0x82, 0xb7, 0x31, 0x9d, 0x0f, 0xb5, 0xdb, 0xc4, 0x2d,
	0x74, 0x13, 0x0d, 0xc1, 0x31, 0x88, 0xa0, 0xf8, 0x02, 0xac, 0x29, 0xc5, 0x72, 0x7a, 0x33, 0xf1,
	0x75, 0x43, 0x53, 0xae, 0x65, 0x6c, 0xbf, 0xd1, 0x29, 0x5d, 0x1c, 0x9d, 0xa1, 0x3b, 0xcb, 0xc3,
	0x45, 0x5d, 0xd2, 0xb3, 0x7e, 0xe1, 0xb6, 0xde, 0xd7, 0x7e, 0x8e, 0x1a, 0x34, 0xc2, 0xc6, 0x76,
	0x1a, 0x34, 0xaa, 0xa4, 0xc9, 0x0a, 0xc7, 0x3c, 0x88, 0xeb, 0xe2, 0xec, 0x09, 0x60, 0x5e, 0x24,
	0x36, 0x8f, 0x0e, 0x16, 0x97, 0x98, 0x30, 0xd4, 0x40, 0xdf, 0x0e, 0xa5, 0x19, 0x9a, 0xbc, 0x1d,
	0xcf, 0x41, 0xda, 0x5b, 0x7b, 0x79, 0x86, 0x29, 0x82, 0x5a, 0xe7, 0x42, 0xe3, 0x9d, 0x88, 0xf7,
	0x11, 0xf7, 0x20, 0x62, 0x9f, 0x79, 0xe3, 0x85, 0xb1, 0x69, 0xc7, 0x25, 0x8e, 0x71, 0xb9, 0x2e,
	0xfa, 0xc0, 0x3c, 0xfb, 0xd4, 0x09, 0xb9, 0x5b, 0x11, 0x43, 0xe4, 0x36, 0xf7, 0x4d, 0xca, 0xcf,
	0x35, 0x51, 0x3a, 0xb2, 0xba, 0x33, 0xa6, 0x0c, 0xd2, 0x78, 0x69, 0x3f, 0x6a, 0xd4, 0x42, 0xb7,
	0x24, 0x39, 0x24, 0x11, 0x47, 0xcf, 0x80, 0x70, 0xf3, 0x80, 0xe7, 0xc8, 0xc1, 0x60, 0x8c, 0xed,
	0x8d, 0x74, 0xe5, 0x6e, 0xf7, 0x3e, 0x0a, 0x40, 0x04, 0x87, 0x5b, 0xb2, 0x58, 0x08, 0xf4, 0xcf,
	0x5c, 0xbd, 0xd6, 0xc8, 0xae, 0x9a, 0x9e, 0x08, 0x95, 0x06, 0x2d, 0x92, 0xe4, 0x43, 0xf0, 0xd9,
	0x02, 0xfa, 0x48, 0xe8, 0x16, 0x75, 0x14, 0x6a, 0x43, 0x58, 0x8e, 0xe4, 0x29, 0xf6, 0x58, 0x33,
	0x76, 0xfc, 0x3e, 0x38, 0x7c, 0xcb, 0x0b, 0x8d, 0x6c, 0x96, 0xe7, 0x85, 0x04, 0xa3, 0x3e, 0x47,
	0x19, 0x52, 0x63, 0x48, 0x8c, 0x75, 0x58, 0x9d, 0x96, 0xb8, 0x45, 0xba, 0xfd, 0x96, 0x1b, 0xa1,
	0x35, 0x23, 0xa8, 0xaf, 0x97, 0x65, 0x66, 0xc3, 0xfe, 0x12, 0x76, 0x11, 0xa5, 0xed, 0xf3, 0x23,
	0x86, 0xa8, 0x56, 0xfa, 0xb3, 0x57, 0xfa, 0x12, 0x73, 0xff, 0x85, 0x43, 0x87, 0xff, 0xd7, 0x44,
	0x96, 0x48, 0xc0, 0xea, 0x90, 0xd2, 0xb8, 0x4c, 0x9e, 0x98, 0x92, 0x66, 0x46, 0xa4, 0x2e, 0x3a,
	0x11, 0xe2, 0xff, 0xae, 0xf6, 0x74, 0x3f, 0x0c, 0x71, 0xf8, 0xd7, 0xfc, 0xdf, 0x5e, 0x89, 0x9a,
	0x5f, 0x30, 0xda, 0xc2, 0x7b, 0xf3, 0x0e, 0x85, 0xed, 0x1f, 0x62, 0x16, 0x2f, 0xfd, 0xea, 0x89,
	0xb4, 0xa9, 0x8b, 0xd8, 0x2c, 0x6d, 0xac, 0xae, 0x75, 0x5e, 0x66, 0x68, 0xf4, 0xa1, 0x0e, 0x4d,
	0x3a, 0x4d, 0x03, 0x40, 0x77, 0x41, 0xd2, 0x61, 0x45, 0x79, 0x29, 0x41, 0x75, 0x5d, 0xf1, 0xa4,
	0x47, 0x88, 0xdd, 0x7d, 0x91, 0x6a, 0x32, 0xc0, 0x9a, 0xcf, 0x48, 0x1e, 0x93, 0xb3, 0x86, 0x36,
	0x9a, 0x00, 0xa2, 0x3e, 0x22, 0x0f, 0x5d, 0x51, 0x4b, 0xd0, 0xef, 0x2a, 0xb8, 0x80, 0xb4, 0x32,
	0x8a, 0x6c, 0x90, 0x5e, 0xfb, 0xa4, 0x04, 0x7f, 0x06, 0x92, 0xaf, 0xe2, 0xf9, 0x6e, 0x89, 0x87,
	0xac, 0x19, 0x40, 0x42, 0x6a, 0x83, 0xd7, 0xc3, 0x3f, 0xaf, 0x5e, 0x06, 0xc9, 0x65, 0xf7, 0x5b,
	0x04, 0x5c, 0x8a, 0x8b, 0x6d, 0x94, 0x67, 0x8e, 0x8f, 0xbb, 0x08, 0xf8, 0x87, 0x8d, 0xc3, 0xbb,
	0x72, 0x66, 0x11, 0x5f, 0xf2, 0x19, 0x66, 0x87, 0x76, 0x65, 0x44, 0xdb, 0xa1, 0x02, 0x18, 0xac,
	0x69, 0xd0, 0x11, 0xfc, 0xfc, 0x0a, 0xa4, 0x91, 0x7e, 0x26, 0xd5, 0x85, 0x5d, 0x4a, 0x52, 0x59,
	0x4d, 0x9e, 0x50, 0x75, 0xf2, 0x06, 0x71, 0xac, 0xd1, 0x4d, 0xa6, 0xda, 0xeb, 0x06, 0x32, 0x07,
	0x25, 0xce, 0x42, 0x76, 0x6d, 0x70, 0x59, 0x35, 0xce, 0xd9, 0x68, 0x37, 0x56, 0x5b, 0xb9, 0x13,
	0x17, 0xc8, 0x7b, 0x1e, 0x3a, 0x03, 0xb8, 0xc3, 0x06, 0xfa, 0xb2, 0x97, 0x1c, 0x79, 0xda, 0x41,
	0x8b, 0x1b, 0xac, 0xf4, 0x5a, 0x35, 0x1a, 0xd9, 0x84, 0xb6, 0xd0, 0x87, 0xf0, 0xed, 0x90, 0x32,
	0x26, 0x29, 0x60, 0x71, 0x1e, 0xd7, 0xac, 0xa0, 0x83, 0x5d, 0xb2, 0x34, 0xa3, 0x1d, 0xf3, 0xce,
	0xbe, 0x9f, 0x74, 0xd4, 0x6d, 0x9d, 0x4b, 0x5d, 0x25, 0xdd, 0xe5, 0xf1, 0xed, 0xcd, 0xb5, 0xb2,
	0xe6, 0x46, 0xf8, 0x9f, 0x26, 0x2a, 0xe5, 0x05, 0xf0, 0x32, 0xed, 0x54, 0xda, 0x25, 0x36, 0x8a,
	0xff, 0xf3, 0xaf, 0x78, 0x9a, 0x56, 0x7e, 0x44, 0x0c, 0xc3, 0x3e, 0x94, 0x7f, 0xe7, 0xc4, 0xfb,
	0x38, 0x5e, 0x95, 0x6a, 0x53, 0x7d, 0x39, 0x3b, 0x63, 0x01, 0xeb, 0x7f, 0xc7, 0x85, 0xc5, 0xc5,
	0xde, 0xce, 0xae, 0x07, 0xae, 0x86, 0xad, 0xed, 0xb2, 0x4f, 0xe7, 0x7b, 0x9e, 0xbf, 0x00, 0x21,
	0x89, 0x7b, 0xd0, 0x96, 0x31, 0x23, 0x9e, 0x38, 0x38, 0x3d, 0x5d, 0xcc, 0xe4, 0xb0, 0x3e, 0xb5,
	0xdc, 0xf2, 0x82, 0x7e, 0x31, 0x33, 0xb5, 0x90, 0x24, 0xa3, 0xf4, 0x1c, 0x0d, 0x15, 0xe9, 0x0c,
	0x14, 0x83, 0x32, 0x06, 0x0b, 0x67, 0x38, 0xf9, 0x88, 0xc9, 0x82, 0x9d, 0x51, 0xa1, 0x7a, 0x86,
	0x22, 0xd5, 0x43, 0x6d, 0x15, 0x60, 0x10, 0x6b, 0x53, 0x2b, 0x3f, 0xe6, 0xdb, 0x60, 0x84, 0xe4,
	0xa0, 0x50, 0x36, 0x6e, 0x1b, 0x91, 0xa3, 0x24, 0x73, 0xa0, 0xfe, 0x32, 0x9b, 0x03, 0xa1, 0x07,
	0xd1, 0x4e, 0x78, 0xe4, 0x3b, 0x76, 0xf7, 0xe2, 0x53, 0xff, 0x96, 0x22, 0xf2, 0x24, 0xfb, 0xad,
	0xfd, 0x29, 0xfe, 0x9f, 0x42, 0xe6, 0x97, 0xc5, 0xc6, 0x8a, 0x52, 0xb1, 0x6c, 0x2e, 0xea, 0xc9,
	0xfc, 0x28, 0xd0, 0x1d, 0x1e, 0x65, 0xa6, 0xa1, 0x34, 0xae, 0xb9, 0x06, 0xdb, 0x2e, 0xb0, 0x57,
	0xb7, 0x58, 0xb2, 0xbd, 0x23, 0x8c, 0x1f, 0x99, 0xb5, 0x65, 0xc5, 0x4b, 0x08, 0x88, 0xf9, 0x05,
	0x8c, 0xfa, 0x41, 0x03, 0xc7, 0x60, 0xfa, 0x91, 0x79, 0x16, 0xf5, 0xaf, 0xf2, 0x0e, 0x73, 0x2f,
	0xf5, 0xac, 0xc0, 0x4b, 0x88, 0xc8, 0x08, 0x48, 0x66, 0x41, 0x2a, 0x32, 0x8b, 0x46, 0xce, 0xd0,
	0x9d, 0x06, 0xd0, 0xc4, 0x32, 0xe1, 0x15, 0xce, 0x0b, 0x51, 0xd2, 0xc8, 0xc1, 0x03, 0x9c, 0xbd,
	0x03, 0xdb, 0x3d, 0x93, 0x5f, 0x01, 0x95, 0x02, 0x9d, 0xda, 0xbf, 0x09, 0xdf, 0x5e, 0x59, 0x94,
	0xe2, 0x7f, 0x1e, 0x30, 0xdd, 0x65, 0x75, 0x4c, 0x4c, 0x03, 0xf9, 0xf1, 0x1f, 0xaf, 0x79, 0xa2,
	0xc1, 0x13, 0xfb, 0x0e, 0x6e, 0x6d, 0xb9, 0x65, 0xac, 0xb6, 0xbf, 0x93, 0x48, 0x90, 0x38, 0x8d,
	0xd1, 0x83, 0x3f, 0xb8, 0x9a, 0xf5, 0x3d, 0xbb, 0x00, 0x50, 0xa8, 0x55, 0xf2, 0x18, 0xc9, 0x02,
	0xa9, 0xf3, 0xe7, 0xfa, 0x22, 0x61, 0x3c, 0x85, 0x73, 0xf9, 0x79, 0x5f, 0x1d, 0x5f, 0x07, 0x09,
	0x3f, 0xc3, 0x4a, 0xe7, 0x5f, 0x7c, 0x0f, 0xfd, 0x9c, 0x4a, 0xc9, 0x78, 0x26, 0x34, 0x33, 0xe2,
	0xa0, 0x50, 0x5d, 0xb1, 0x40, 0x59, 0xfb, 0xfe, 0x36, 0x7d, 0xcf, 0x36, 0x44, 0x08, 0x29, 0x76,
	0x60, 0x85, 0xa3, 0x0d, 0x70, 0x81, 0xda, 0x41, 0x92, 0x06, 0x79, 0x00, 0x67, 0x1c, 0x41, 0xf6,
	0xee, 0x2d, 0x25, 0x2b, 0x8f, 0x8d, 0x26, 0x2e, 0x1f, 0x92, 0xb0, 0x82, 0xe1, 0x32, 0x3f, 0x35,
	0xd1, 0x81, 0x65, 0xa4, 0x69, 0xa2, 0x6d, 0x57, 0x8b, 0x3e, 0x40, 0x1a, 0x1d, 0x7b, 0x2b, 0x99,
	0x8f, 0x41, 0xbf, 0x2b, 0xd8, 0x5f, 0x20, 0x5d, 0x2a, 0x80, 0xa4, 0x39, 0x5d, 0xcc, 0xe7, 0x90,
	0x28, 0x32, 0x09, 0x1e, 0x3d, 0x50, 0xa0, 0x0b, 0x46, 0x8a, 0xf0, 0xfa, 0x2b, 0xfe, 0x14, 0x42,
	0x17, 0x39, 0x98, 0x31, 0x5e, 0x8f, 0x4e, 0x68, 0x3a, 0x35, 0x3d, 0x86, 0xfe, 0x2a, 0x6c, 0x14,
	0xe7, 0xff, 0x18, 0x9b, 0x82, 0x70, 0x08, 0x6c, 0x36, 0x72, 0xe6, 0x20, 0xd4, 0x9d, 0x79, 0xad,
	0xa8, 0xd3, 0xf3, 0x54, 0x1c, 0x56, 0xbf, 0x0d, 0xd1, 0xb2, 0xd0, 0x38, 0x86, 0x0d, 0x7b, 0x8d,
	0x36, 0xc6, 0xd9, 0x57, 0x35, 0x50, 0xca, 0x0d, 0x8d, 0x37, 0x91, 0xbb, 0xb9, 0x74, 0x37, 0x16,
	0xb8, 0x80, 0xc4, 0x99, 0xb0, 0x50, 0xc0, 0x2a, 0x3d, 0xbf, 0x66, 0xa2, 0x53, 0xe0, 0xe6, 0x0b,
	0x25, 0x36, 0x46, 0xb8, 0x3b, 0x09, 0x9f, 0x88, 0xf0, 0x13, 0x6c, 0x58, 0xf1, 0x6b, 0x8e, 0x06,
	0x39, 0xbb, 0x7b, 0x85, 0x33, 0xe1, 0x18, 0x6d, 0xa7, 0x34, 0x34, 0xaa, 0x8d, 0x69, 0xcb, 0x4d,
	0x45, 0xe0, 0x99, 0x82, 0x24, 0x76, 0xba, 0xfc, 0x82, 0xd5, 0xdd, 0xb8, 0xb2, 0x24, 0x57, 0x91,
	0x28, 0xe2, 0x7a, 0xae, 0x73, 0x9b, 0xf1, 0x25, 0x46, 0xcd, 0xcb, 0x72, 0x68, 0xdd, 0xa1, 0xbf,
	0x11, 0xba, 0x09, 0xc1, 0x1c, 0x56, 0x42, 0x10, 0x80, 0x89, 0x25, 0x13, 0x22, 0xee, 0xde, 0x3c,
	0xd1, 0x96, 0x40, 0xab, 0xbe, 0xdb, 0x45, 0x0c, 0xef, 0x61, 0x93, 0x27, 0x3e, 0x01, 0x23, 0x6b,
	0xa8, 0x85, 0x8c, 0x3d, 0x90, 0xd0, 0x1f, 0x5f, 0xdf, 0xbf, 0x99, 0x87, 0xa1, 0x35, 0xaf, 0x1b,
	0x73, 0x5f, 0xb2, 0x06, 0x35, 0x27, 0x85, 0x70, 0xf4, 0x00, 0x33, 0x46, 0x2c, 0x5f, 0x20, 0x12,
	0x45, 0x49, 0x00, 0x03, 0xee, 0x83, 0x5f, 0x0f, 0x82, 0x5a, 0xd7, 0xfe, 0x20, 0x2b, 0xe6, 0xf7,
	0xe7, 0xc7, 0x39, 0x85, 0xdb, 0xc1, 0x8b, 0x87, 0x2e, 0xe3, 0x11, 0x8c, 0x2b, 0x1e, 0x5b, 0xec,
	0x00, 0xfe, 0x0c, 0x6f, 0x4e, 0xc7, 0xd5, 0x5a, 0x5d, 0x97, 0x9b, 0x18, 0x13, 0x24, 0xd3, 0x95,
	0xe0, 0x40, 0xbd, 0x52, 0x7c, 0xf2, 0xc3, 0xac, 0xbf, 0xab, 0xe3, 0x4f, 0xeb, 0x70, 0xbf, 0x76,
	0xed, 0xcd, 0x38, 0xd7, 0xb7, 0xe8, 0x3f, 0x47, 0xef, 0x95, 0xdb, 0xea, 0x1c, 0xdc, 0x6b, 0x82,
	0x08, 0x8c, 0x3e, 0x8f, 0x6f, 0x13, 0x81, 0x07, 0xcf, 0xc8, 0x87, 0x64, 0xcb, 0x14, 0x3f, 0xb7,
	0x03, 0x57, 0x8d, 0x3e, 0x34, 0x97, 0xcd, 0xd9, 0xd3, 0x12, 0xbf, 0x96, 0x66, 0x0e, 0x5c, 0xd8,
	0xc3, 0xcd, 0x8b, 0xa2, 0xd7, 0x75, 0x09, 0x58, 0xe7, 0x24, 0x57, 0x4d, 0x19, 0x37, 0x90, 0x89,
	0x90, 0xc7, 0x22, 0x58, 0xe0, 0x52, 0xa3, 0x62, 0xbd, 0x73, 0xa9, 0xbe, 0x0e, 0x78, 0xbb, 0xeb,
	0x4c, 0x0b, 0x2f, 0xd0, 0xf0, 0x46, 0x39, 0x99, 0x1a, 0x6e, 0x66, 0x82, 0x34, 0x77, 0x52, 0x88,
	0x2f, 0xca, 0xb5, 0xc9, 0x64, 0xaa, 0xde, 0xcd, 0x1c, 0xb7, 0xd5, 0x9c, 0x3f, 0x87, 0x6d, 0x96,
	0x7b, 0x06, 0xb7, 0x61, 0x8f, 0x1e, 0xe8, 0xab, 0x01, 0xfa, 0x80, 0x06, 0x69, 0x91, 0x7a, 0x8c,
	0xd2, 0x21, 0xcd, 0x06, 0xcf, 0x6d, 0x5a, 0x76, 0x13, 0x67, 0xae, 0x71, 0x70, 0x9a, 0x3d, 0xb6,
	0x48, 0xec, 0x42, 0x7a, 0x27, 0x33, 0x2e, 0xf8, 0xb2, 0xa1, 0x59, 0xfb, 0x4b, 0x3b, 0xbc, 0x1b,
	0x70, 0xcc, 0x88, 0x7c, 0x6c, 0x10, 0xde, 0xa3, 0x6c, 0xf2, 0x89, 0x49, 0xa2, 0x79, 0x89, 0x0d,
	0xd5, 0xc5, 0xa2, 0x32, 0x74, 0x9e, 0x39, 0xa3, 0x0f, 0x80, 0x5f, 0x83, 0x13, 0xdf, 0xc0, 0x14,
	0x15, 0xb9, 0x70, 0xbb, 0xc6, 0x82, 0x2a, 0x97, 0x85, 0xe5, 0xb2, 0x0a, 0x6a, 0x61, 0x10, 0xc3,
	0xbb, 0xf1, 0x2d, 0x44, 0x5e, 0xed, 0x74, 0x68, 0x39, 0x8d, 0xbf, 0x82, 0x97, 0x14, 0x3e, 0x11,
	0x81, 0xbb, 0x4a, 0x2a, 0x11, 0x09, 0xa4, 0x9e, 0xc2, 0xd9, 0x97, 0x1f, 0xfc, 0x20, 0x9c, 0x8f,
	0xcf, 0x47, 0x9d, 0x5d, 0xf8, 0xe6, 0xbb, 0x06, 0x68, 0xda, 0x07, 0xcf, 0x5b, 0x89, 0x6e, 0x43,
	0xa6, 0x10, 0x86, 0x86, 0xd8, 0x1d, 0x4a, 0xa9, 0x97, 0x2e, 0x0d, 0xf4, 0xb8, 0x9b, 0x5a, 0xe2,
	0x47, 0xe6, 0xa5, 0xe2, 0xfb, 0xf5, 0xd1, 0xd3, 0x73, 0x75, 0xc8, 0xe6, 0xb5, 0x22, 0x30, 0x38,
	0xf1, 0x70, 0x11, 0x8b, 0x3f, 0x93, 0xc8, 0xf2, 0x45, 0x9a, 0x36, 0xb5, 0x16, 0x2c, 0x2a, 0x7b,
	0x08, 0xfe, 0x90, 0x4a, 0x0d, 0xe0, 0x1c, 0x77, 0x8e, 0xbc, 0x67, 0x42, 0xb3, 0x92, 0xa1, 0x4b,
	0x27, 0x49, 0xfd, 0x3e, 0x8d, 0x9b, 0x7f, 0x94, 0xb2, 0xbf, 0xc4, 0x91, 0xac, 0x5f, 0x34, 0x67,
	0xf6, 0x61, 0xd4, 0xbb, 0x75, 0xfc, 0xe7, 0x22, 0x7e, 0x88, 0x6c, 0x4a, 0x6a, 0xc0, 0xce, 0x51,
	0xe3, 0x35, 0x62, 0x8f, 0x36, 0x9a, 0xa3, 0x10, 0x5f, 0x77, 0xda, 0xc4, 0xea, 0x13, 0xdb, 0xd5,
	0x44, 0x87, 0x8a, 0xc6, 0x96, 0xc2, 0x93, 0x78, 0x19, 0x95, 0x67, 0x09, 0x7c, 0x3a, 0xf4, 0xc4,
	0xa5, 0x78, 0x62, 0x52, 0x35, 0x14, 0xf5, 0x65, 0x39, 0xff, 0xb4, 0xc3, 0x61, 0xe5, 0xf3, 0x1c,
	0xac, 0x07, 0x76, 0x99, 0xa1, 0xd2, 0xde, 0x2d, 0x30, 0x6b, 0xbc, 0xf8, 0xdb, 0x2b, 0x98, 0xa1,
	0x8d, 0xd8, 0x2f, 0x3d, 0x58, 0x49, 0x1a, 0xb2, 0x2c, 0x39, 0xdb, 0xd4, 0x37, 0xd0, 0x73, 0x33,
	0xb2, 0x4e, 0x46, 0x28, 0x6f, 0xdb, 0x33, 0x59, 0xd3, 0xbd, 0x40, 0xa4, 0xd4, 0xa5, 0x5a, 0xfe,
	0xdd, 0xbe, 0xa6, 0x8e, 0xe1, 0x24, 0xb5, 0x61, 0x2d, 0x44, 0x4f, 0x09, 0x7a, 0xb5, 0xf6, 0x0d,
	0xf6, 0xdd, 0xbb, 0x5b, 0x23, 0xea, 0xde, 0xac, 0xbe, 0xa5, 0x5e, 0x4c, 0x71, 0x2f, 0x3c, 0x69,
	0x54, 0x6d, 0x9f, 0x7f, 0x97, 0xc0, 0x21, 0x10, 0x7b, 0x68, 0xa2, 0x35, 0x02, 0xf2, 0x29, 0xc2,
	0xb1, 0x7b, 0xd3, 0xf4, 0xf1, 0x9d, 0x62, 0xe2, 0x10, 0x6a, 0x53, 0x1f, 0xf9, 0x59, 0x46, 0x1c,
	0xb5, 0x3b, 0x0d, 0x73, 0xa1, 0x9a, 0xcb, 0xbc, 0xa2, 0x3b, 0x98, 0xf9, 0x73, 0x96, 0xe0, 0x70,
	0xaf, 0xef, 0x91, 0xe9, 0x0c, 0x36, 0x0b, 0x4d, 0x0a, 0xd0, 0xf4, 0x2e, 0xc1, 0xa9, 0xbe, 0x59,
	0x37, 0x4b, 0xc6, 0x34, 0xf8, 0xc9, 0xb7, 0x0b, 0xec, 0xee, 0xf8, 0xaa, 0x32, 0x28, 0xfc, 0x97,
	0x41, 0x7c, 0xe0, 0xd8, 0x0c, 0xd0, 0xa5, 0x1b, 0xb9, 0xee, 0x4a, 0x11, 0x05, 0x44, 0x5c, 0xe2,
	0xba, 0x2b, 0x1b, 0x97, 0xf2, 0xcb, 0x1a, 0x57, 0x78, 0xa7, 0x4f, 0xf4, 0x6e, 0x04, 0xfc, 0xd1,
	0xc4, 0x6f, 0x49, 0xb4, 0x2e, 0xce, 0x4e, 0x3c, 0x24, 0x6e, 0x9a, 0x6a, 0xeb, 0x8e, 0x14, 0xa3,
	0xa7, 0x17, 0x48, 0xb5, 0xe0, 0x85, 0x47, 0x44, 0xd2, 0x86, 0x84, 0xc3, 0xb8, 0x6d, 0x1a, 0xbd,
	0xfd, 0x1c, 0x5e, 0xd7, 0x8e, 0x24, 0x26, 0xda, 0xcc, 0xf5, 0x2c, 0xb3, 0xc6, 0xa5, 0x5a, 0xee,
	0xf4, 0x73, 0xf1, 0x0a, 0x98, 0xfa, 0xc8, 0x20, 0xca, 0x3f, 0x62, 0x3c, 0x2f, 0xa8, 0xe3, 0xe7,
	0xf9, 0xbf, 0x6a, 0x82, 0xd5, 0x0d, 0x8b, 0x9f, 0x7f, 0x87, 0x43, 0xe1, 0x2d, 0xc0, 0x04, 0x41,
	0x6d, 0xed, 0x50, 0xd2, 0x7e, 0x9a, 0x70, 0x67, 0x5a, 0x66, 0x84, 0x3e, 0x3d, 0xb0, 0x8c, 0xf5,
	0x7b, 0x3e, 0x5f, 0x8f, 0xc5, 0xad, 0xaf, 0xd6, 0x86, 0xf7, 0xd8, 0xbe, 0x05, 0xd4, 0x8d, 0xaa,
	0x7f, 0x12, 0xe2, 0x64, 0x10, 0x31, 0x00, 0x42, 0xfa, 0xdc, 0xe5, 0xea, 0x8d, 0x9f, 0x1c, 0x9f,
	0x66, 0x34, 0xcd, 0x06, 0x94, 0x93, 0x39, 0xf1, 0xbc, 0x5a, 0xfa, 0x98, 0x72, 0x8c, 0x29, 0x35,
	0xb3, 0x8f, 0x00, 0xde, 0xe1, 0x3d, 0xe3, 0x4e, 0x16, 0xdc, 0x52, 0x87, 0x4b, 0x79, 0x87, 0x0f,
	0x4c, 0x1f, 0x36, 0x7f, 0x07, 0xc2, 0x8c, 0xad, 0x8e, 0x1a, 0x21, 0x6d, 0xc7, 0x61, 0x2e, 0x9e,
	0x78, 0x14, 0x1a, 0x0f, 0xff, 0x6b, 0xa5, 0x0a, 0xfb, 0x49, 0xaf, 0x0d, 0xc7, 0x8e, 0xc7, 0x52,
	0xd8, 0xae, 0x58, 0x34, 0x09, 0x19, 0x6a, 0xa8, 0x71, 0x0f, 0x81, 0x50, 0x86, 0x44, 0x64, 0x61,
	0x68, 0x7c, 0x3f, 0xa9, 0xe6, 0xf9, 0xba, 0x70, 0x6e, 0xb7, 0x07, 0x5b, 0xf0, 0xe0, 0x0c, 0xa5,
	0x5e, 0x45, 0x86, 0x4b, 0x43, 0x97, 0x09, 0x52, 0xf9, 0x94, 0xca, 0x0c, 0x6f, 0xe7, 0xf3, 0x33,
	0x3a, 0x4c, 0x4b, 0x5b, 0x72, 0xe3, 0xeb, 0x03, 0xfd, 0xf5, 0x5f, 0x36, 0x8f, 0xcf, 0x5d, 0x75,
	0x9a, 0xd0, 0x29, 0x21, 0xc5, 0x56, 0xcf, 0x8d, 0x87, 0x2b, 0x57, 0x2f, 0xea, 0x8a, 0x47, 0x0d,
	0xee, 0xe8, 0x84, 0xcf, 0xb5, 0xc3, 0xbc, 0xaf, 0xed, 0x6b, 0xf6, 0xca, 0xdd, 0x73, 0x6f, 0x77,
	0x60, 0x11, 0x87, 0xea, 0x55, 0x9c, 0x06, 0x51, 0xf1, 0x79, 0xe1, 0x37, 0x11, 0x78, 0xa7, 0xf1,
	0xc6, 0x65, 0x79, 0x43, 0xaa, 0x30, 0x5f, 0x5b, 0x79, 0x42, 0x57, 0x43, 0x61, 0x54, 0x31, 0x54,
	0x88, 0x05, 0x94, 0x89, 0x82, 0x2e, 0x92, 0x2d, 0xfd, 0x02, 0xfb, 0x46, 0x06, 0x4f, 0x7b, 0xde,
	0xa9, 0xb9, 0xb6, 0x3f, 0xfe, 0x7c, 0x81, 0xcd, 0x64, 0xb7, 0xc7, 0x11, 0xb4, 0x44, 0x43, 0x1b,
	0x22, 0x12, 0x21, 0x75, 0x90, 0x44, 0x04, 0xbb, 0x46, 0x91, 0x4a, 0xa4, 0x64, 0x11, 0xeb, 0xc5,
	0xa5, 0xbc, 0xab, 0x3e, 0x6f, 0x80, 0x1e, 0x49, 0x08, 0xa0, 0xa9, 0x45, 0x7e, 0x88, 0x40, 0x9e,
	0xe9, 0xd1, 0xa1, 0x6d, 0xff, 0xd3, 0x3e, 0xcd, 0x71, 0x54, 0xbb, 0x86, 0x20, 0x3e, 0x05, 0x5e,
	0xb5, 0xdd, 0xc1, 0x5a, 0x5b, 0xdd, 0xa2, 0xea, 0xa0, 0xb1, 0x5b, 0xe9, 0xf3, 0xfa, 0x1a, 0xe7,
	0xde, 0xc9, 0x38, 0x96, 0x2d, 0x25, 0xec, 0x5d, 0x98, 0xca, 0x00, 0x69, 0x2b, 0x2f, 0xaf, 0xac,
	0x9c, 0x70, 0xdf, 0xe9, 0xe0, 0xd1, 0x49, 0x62, 0xc1, 0xe8, 0xc7, 0x82, 0x5d, 0xff, 0xcf, 0x11,
};

/// @endcond HIDDEN_SYMBOLS

/**
  * @brief    Initialize TSI command interface
  * @return   0               success
  * @return   otherwise       error code from TSI
  */
int TSI_Init(void)
{
	uint64_t t0, t1;
	TSI_REQ_T  req;
	int ret;

#ifdef USE_IRQ
	set_whc1_irq_flag(0);
	IRQ_SetHandler(WRHO1_IRQn, WRHO1_IRQHandler);
	WHC1->INTSTS = 0xffffffff;
	IRQ_Enable(WRHO1_IRQn);
	WHC1->INTEN |= 0x0f00003f;   /* enable RX0~RX3 interrupt */
#else
	WHC1->INTSTS = 0xffffffff;
	WHC1->INTEN = 0x0;
#endif

	t0 = EL0_GetCurrentPhysicalValue();
	while (TSI_Sync() != 0) {
		if (EL0_GetCurrentPhysicalValue() - t0 > 1200000)
			return ST_WAIT_TSI_SYNC;
	}

	TSI_Reset();

	t0 = EL0_GetCurrentPhysicalValue();
	while (TSI_Sync() != 0) {
		if (EL0_GetCurrentPhysicalValue() - t0 > 1200000) /* 100 ms timeout */
			return ST_WAIT_TSI_SYNC;
	}

	/* load patch image */
	ret = TSI_Load_Image(ptr_to_u32(tsi_patch_image), sizeof(tsi_patch_image));
	if (ret != 0)
	{
		sysprintf("[%d] TSI_Load_Image failed! - 0x%x\n", get_time(), ret);
		return ret;
	}

	memset(&req, 0, sizeof(req));
	req.cmd[0] = (0xFA01 << 16);
	req.cmd[1] = 180000000;
	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
	if (ret != 0)
		return ret;

	return 0;
}

/*! @}*/ /* end of group TSI_EXPORTED_FUNCTIONS */

/*! @}*/ /* end of group TSI_Driver */

/*! @}*/ /* end of group Standard_Driver */
